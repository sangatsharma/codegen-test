/**
 * Generated by @openapi-codegen
 *
 * @version 1.0
 */
import * as reactQuery from "@tanstack/react-query";
import { useApiContext, ApiContext } from "./apiContext";
import type * as Fetcher from "./apiFetcher";
import { apiFetch } from "./apiFetcher";
import type * as Schemas from "./apiSchemas.ts";

export type VacancyControllerCreateJobVacancyError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        message: string;
        /**
         * @example Bad Request
         */
        error?: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        message: string;
        /**
         * @example Unauthorized
         */
        error?: string;
      };
    }
  | {
      status: 406;
      payload: {
        /**
         * @example 406
         */
        statusCode: number;
        message: {
          [key: string]: string[];
        };
        /**
         * @example Validation Exception
         */
        error?: string;
      };
    }
  | {
      status: 500;
      payload: {
        /**
         * @example 500
         */
        statusCode: number;
        message: string;
        /**
         * @example Internal Server Error
         */
        error?: string;
      };
    }
>;

export type VacancyControllerCreateJobVacancyVariables = {
  body: Schemas.CreateVacancyRequestDto;
} & ApiContext["fetcherOptions"];

export const fetchVacancyControllerCreateJobVacancy = (
  variables: VacancyControllerCreateJobVacancyVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.MessageResponseWithIdDTO,
    VacancyControllerCreateJobVacancyError,
    Schemas.CreateVacancyRequestDto,
    {},
    {},
    {}
  >({ url: "/vacancy", method: "post", ...variables, signal });

export const useVacancyControllerCreateJobVacancy = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.MessageResponseWithIdDTO,
      VacancyControllerCreateJobVacancyError,
      VacancyControllerCreateJobVacancyVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.MessageResponseWithIdDTO,
    VacancyControllerCreateJobVacancyError,
    VacancyControllerCreateJobVacancyVariables
  >({
    mutationFn: (variables: VacancyControllerCreateJobVacancyVariables) =>
      fetchVacancyControllerCreateJobVacancy({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type VacancyControllerGetAllJobVacancyQueryParams = {
  /**
   * @minimum 0
   */
  take?: number;
  /**
   * @minimum 0
   */
  page?: number;
  search?: string;
  designationId?: string;
  status?: "Archive" | "Active";
  jobLevel?: string;
  /**
   * @format date-time
   */
  datePostedFrom?: string;
  /**
   * @format date-time
   */
  datePostedTo?: string;
  /**
   * @format date-time
   */
  deadlineFrom?: string;
  /**
   * @format date-time
   */
  deadlineTo?: string;
};

export type VacancyControllerGetAllJobVacancyError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        message: string;
        /**
         * @example Bad Request
         */
        error?: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        message: string;
        /**
         * @example Unauthorized
         */
        error?: string;
      };
    }
  | {
      status: 500;
      payload: {
        /**
         * @example 500
         */
        statusCode: number;
        message: string;
        /**
         * @example Internal Server Error
         */
        error?: string;
      };
    }
>;

export type VacancyControllerGetAllJobVacancyVariables = {
  queryParams?: VacancyControllerGetAllJobVacancyQueryParams;
} & ApiContext["fetcherOptions"];

export const fetchVacancyControllerGetAllJobVacancy = (
  variables: VacancyControllerGetAllJobVacancyVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.ListVacanciesReponseDto,
    VacancyControllerGetAllJobVacancyError,
    undefined,
    {},
    VacancyControllerGetAllJobVacancyQueryParams,
    {}
  >({ url: "/vacancy", method: "get", ...variables, signal });

export const useVacancyControllerGetAllJobVacancy = <
  TData = Schemas.ListVacanciesReponseDto,
>(
  variables: VacancyControllerGetAllJobVacancyVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ListVacanciesReponseDto,
      VacancyControllerGetAllJobVacancyError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.ListVacanciesReponseDto,
    VacancyControllerGetAllJobVacancyError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/vacancy",
      operationId: "vacancyControllerGetAllJobVacancy",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchVacancyControllerGetAllJobVacancy(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type VacancyControllerFindSingleVacancyPathParams = {
  vacancyId: string;
};

export type VacancyControllerFindSingleVacancyError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        message: string;
        /**
         * @example Bad Request
         */
        error?: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        message: string;
        /**
         * @example Unauthorized
         */
        error?: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        message: string;
        /**
         * @example Not Found
         */
        error?: string;
      };
    }
  | {
      status: 500;
      payload: {
        /**
         * @example 500
         */
        statusCode: number;
        message: string;
        /**
         * @example Internal Server Error
         */
        error?: string;
      };
    }
>;

export type VacancyControllerFindSingleVacancyVariables = {
  pathParams: VacancyControllerFindSingleVacancyPathParams;
} & ApiContext["fetcherOptions"];

export const fetchVacancyControllerFindSingleVacancy = (
  variables: VacancyControllerFindSingleVacancyVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.GetVacancyResponseDto,
    VacancyControllerFindSingleVacancyError,
    undefined,
    {},
    {},
    VacancyControllerFindSingleVacancyPathParams
  >({ url: "/vacancy/{vacancyId}", method: "get", ...variables, signal });

export const useVacancyControllerFindSingleVacancy = <
  TData = Schemas.GetVacancyResponseDto,
>(
  variables: VacancyControllerFindSingleVacancyVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.GetVacancyResponseDto,
      VacancyControllerFindSingleVacancyError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.GetVacancyResponseDto,
    VacancyControllerFindSingleVacancyError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/vacancy/{vacancyId}",
      operationId: "vacancyControllerFindSingleVacancy",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchVacancyControllerFindSingleVacancy(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type VacancyControllerUpdateJobVacancyPathParams = {
  vacancyId: string;
};

export type VacancyControllerUpdateJobVacancyError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        message: string;
        /**
         * @example Bad Request
         */
        error?: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        message: string;
        /**
         * @example Unauthorized
         */
        error?: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        message: string;
        /**
         * @example Not Found
         */
        error?: string;
      };
    }
  | {
      status: 406;
      payload: {
        /**
         * @example 406
         */
        statusCode: number;
        message: {
          [key: string]: string[];
        };
        /**
         * @example Validation Exception
         */
        error?: string;
      };
    }
  | {
      status: 500;
      payload: {
        /**
         * @example 500
         */
        statusCode: number;
        message: string;
        /**
         * @example Internal Server Error
         */
        error?: string;
      };
    }
>;

export type VacancyControllerUpdateJobVacancyVariables = {
  body?: Schemas.UpdateVacancyRequestDto;
  pathParams: VacancyControllerUpdateJobVacancyPathParams;
} & ApiContext["fetcherOptions"];

export const fetchVacancyControllerUpdateJobVacancy = (
  variables: VacancyControllerUpdateJobVacancyVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.MessageResponseWithIdDTO,
    VacancyControllerUpdateJobVacancyError,
    Schemas.UpdateVacancyRequestDto,
    {},
    {},
    VacancyControllerUpdateJobVacancyPathParams
  >({ url: "/vacancy/{vacancyId}", method: "patch", ...variables, signal });

export const useVacancyControllerUpdateJobVacancy = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.MessageResponseWithIdDTO,
      VacancyControllerUpdateJobVacancyError,
      VacancyControllerUpdateJobVacancyVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.MessageResponseWithIdDTO,
    VacancyControllerUpdateJobVacancyError,
    VacancyControllerUpdateJobVacancyVariables
  >({
    mutationFn: (variables: VacancyControllerUpdateJobVacancyVariables) =>
      fetchVacancyControllerUpdateJobVacancy({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type VacancyControllerDeleteJobVacancyPathParams = {
  vacancyId: string;
};

export type VacancyControllerDeleteJobVacancyError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        message: string;
        /**
         * @example Bad Request
         */
        error?: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        message: string;
        /**
         * @example Unauthorized
         */
        error?: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        message: string;
        /**
         * @example Not Found
         */
        error?: string;
      };
    }
  | {
      status: 500;
      payload: {
        /**
         * @example 500
         */
        statusCode: number;
        message: string;
        /**
         * @example Internal Server Error
         */
        error?: string;
      };
    }
>;

export type VacancyControllerDeleteJobVacancyVariables = {
  pathParams: VacancyControllerDeleteJobVacancyPathParams;
} & ApiContext["fetcherOptions"];

export const fetchVacancyControllerDeleteJobVacancy = (
  variables: VacancyControllerDeleteJobVacancyVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.MessageResponseDTO,
    VacancyControllerDeleteJobVacancyError,
    undefined,
    {},
    {},
    VacancyControllerDeleteJobVacancyPathParams
  >({ url: "/vacancy/{vacancyId}", method: "delete", ...variables, signal });

export const useVacancyControllerDeleteJobVacancy = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.MessageResponseDTO,
      VacancyControllerDeleteJobVacancyError,
      VacancyControllerDeleteJobVacancyVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.MessageResponseDTO,
    VacancyControllerDeleteJobVacancyError,
    VacancyControllerDeleteJobVacancyVariables
  >({
    mutationFn: (variables: VacancyControllerDeleteJobVacancyVariables) =>
      fetchVacancyControllerDeleteJobVacancy({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type ApplicantControllerCreateApplicantError =
  Fetcher.ErrorWrapper<undefined>;

export type ApplicantControllerCreateApplicantVariables = {
  body: Schemas.CreateApplicantDto;
} & ApiContext["fetcherOptions"];

export const fetchApplicantControllerCreateApplicant = (
  variables: ApplicantControllerCreateApplicantVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.MessageResponseWithIdDTO,
    ApplicantControllerCreateApplicantError,
    Schemas.CreateApplicantDto,
    {},
    {},
    {}
  >({ url: "/applicant", method: "post", ...variables, signal });

export const useApplicantControllerCreateApplicant = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.MessageResponseWithIdDTO,
      ApplicantControllerCreateApplicantError,
      ApplicantControllerCreateApplicantVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.MessageResponseWithIdDTO,
    ApplicantControllerCreateApplicantError,
    ApplicantControllerCreateApplicantVariables
  >({
    mutationFn: (variables: ApplicantControllerCreateApplicantVariables) =>
      fetchApplicantControllerCreateApplicant({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type ApplicantControllerGetAllJobApplicantsQueryParams = {
  name?: string;
  position?: string;
  department?: string;
  /**
   * @minimum 0
   */
  take?: number;
  /**
   * @minimum 0
   */
  page?: number;
};

export type ApplicantControllerGetAllJobApplicantsError =
  Fetcher.ErrorWrapper<undefined>;

export type ApplicantControllerGetAllJobApplicantsVariables = {
  queryParams?: ApplicantControllerGetAllJobApplicantsQueryParams;
} & ApiContext["fetcherOptions"];

export const fetchApplicantControllerGetAllJobApplicants = (
  variables: ApplicantControllerGetAllJobApplicantsVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.ListApplicantsResponseDTO,
    ApplicantControllerGetAllJobApplicantsError,
    undefined,
    {},
    ApplicantControllerGetAllJobApplicantsQueryParams,
    {}
  >({ url: "/applicant", method: "get", ...variables, signal });

export const useApplicantControllerGetAllJobApplicants = <
  TData = Schemas.ListApplicantsResponseDTO,
>(
  variables: ApplicantControllerGetAllJobApplicantsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ListApplicantsResponseDTO,
      ApplicantControllerGetAllJobApplicantsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.ListApplicantsResponseDTO,
    ApplicantControllerGetAllJobApplicantsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/applicant",
      operationId: "applicantControllerGetAllJobApplicants",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchApplicantControllerGetAllJobApplicants(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type ApplicantControllerGetSingleApplicantPathParams = {
  applicantId: string;
};

export type ApplicantControllerGetSingleApplicantError =
  Fetcher.ErrorWrapper<undefined>;

export type ApplicantControllerGetSingleApplicantVariables = {
  pathParams: ApplicantControllerGetSingleApplicantPathParams;
} & ApiContext["fetcherOptions"];

export const fetchApplicantControllerGetSingleApplicant = (
  variables: ApplicantControllerGetSingleApplicantVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.SingleApplicantResponseDTO,
    ApplicantControllerGetSingleApplicantError,
    undefined,
    {},
    {},
    ApplicantControllerGetSingleApplicantPathParams
  >({ url: "/applicant/{applicantId}", method: "get", ...variables, signal });

export const useApplicantControllerGetSingleApplicant = <
  TData = Schemas.SingleApplicantResponseDTO,
>(
  variables: ApplicantControllerGetSingleApplicantVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.SingleApplicantResponseDTO,
      ApplicantControllerGetSingleApplicantError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.SingleApplicantResponseDTO,
    ApplicantControllerGetSingleApplicantError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/applicant/{applicantId}",
      operationId: "applicantControllerGetSingleApplicant",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchApplicantControllerGetSingleApplicant(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type ApplicantControllerPatchApplicantStatusPathParams = {
  applicantId: string;
};

export type ApplicantControllerPatchApplicantStatusError =
  Fetcher.ErrorWrapper<undefined>;

export type ApplicantControllerPatchApplicantStatusVariables = {
  body?: Schemas.PatchApplicantDto;
  pathParams: ApplicantControllerPatchApplicantStatusPathParams;
} & ApiContext["fetcherOptions"];

export const fetchApplicantControllerPatchApplicantStatus = (
  variables: ApplicantControllerPatchApplicantStatusVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.MessageResponseDTO,
    ApplicantControllerPatchApplicantStatusError,
    Schemas.PatchApplicantDto,
    {},
    {},
    ApplicantControllerPatchApplicantStatusPathParams
  >({ url: "/applicant/{applicantId}", method: "patch", ...variables, signal });

export const useApplicantControllerPatchApplicantStatus = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.MessageResponseDTO,
      ApplicantControllerPatchApplicantStatusError,
      ApplicantControllerPatchApplicantStatusVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.MessageResponseDTO,
    ApplicantControllerPatchApplicantStatusError,
    ApplicantControllerPatchApplicantStatusVariables
  >({
    mutationFn: (variables: ApplicantControllerPatchApplicantStatusVariables) =>
      fetchApplicantControllerPatchApplicantStatus({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type ApplicantControllerDeleteApplicantPathParams = {
  applicantId: string;
};

export type ApplicantControllerDeleteApplicantError =
  Fetcher.ErrorWrapper<undefined>;

export type ApplicantControllerDeleteApplicantVariables = {
  pathParams: ApplicantControllerDeleteApplicantPathParams;
} & ApiContext["fetcherOptions"];

export const fetchApplicantControllerDeleteApplicant = (
  variables: ApplicantControllerDeleteApplicantVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.MessageResponseDTO,
    ApplicantControllerDeleteApplicantError,
    undefined,
    {},
    {},
    ApplicantControllerDeleteApplicantPathParams
  >({
    url: "/applicant/{applicantId}",
    method: "delete",
    ...variables,
    signal,
  });

export const useApplicantControllerDeleteApplicant = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.MessageResponseDTO,
      ApplicantControllerDeleteApplicantError,
      ApplicantControllerDeleteApplicantVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.MessageResponseDTO,
    ApplicantControllerDeleteApplicantError,
    ApplicantControllerDeleteApplicantVariables
  >({
    mutationFn: (variables: ApplicantControllerDeleteApplicantVariables) =>
      fetchApplicantControllerDeleteApplicant({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type ApplicantControllerCreateCommentError =
  Fetcher.ErrorWrapper<undefined>;

export type ApplicantControllerCreateCommentVariables = {
  body: Schemas.CreateCommentDTO;
} & ApiContext["fetcherOptions"];

export const fetchApplicantControllerCreateComment = (
  variables: ApplicantControllerCreateCommentVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.MessageResponseWithIdDTO,
    ApplicantControllerCreateCommentError,
    Schemas.CreateCommentDTO,
    {},
    {},
    {}
  >({ url: "/applicant/comment", method: "post", ...variables, signal });

export const useApplicantControllerCreateComment = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.MessageResponseWithIdDTO,
      ApplicantControllerCreateCommentError,
      ApplicantControllerCreateCommentVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.MessageResponseWithIdDTO,
    ApplicantControllerCreateCommentError,
    ApplicantControllerCreateCommentVariables
  >({
    mutationFn: (variables: ApplicantControllerCreateCommentVariables) =>
      fetchApplicantControllerCreateComment({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type ContactControllerCreateContactError =
  Fetcher.ErrorWrapper<undefined>;

export type ContactControllerCreateContactVariables = {
  body: Schemas.CreateContactDTO;
} & ApiContext["fetcherOptions"];

export const fetchContactControllerCreateContact = (
  variables: ContactControllerCreateContactVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.MessageResponseWithIdDTO,
    ContactControllerCreateContactError,
    Schemas.CreateContactDTO,
    {},
    {},
    {}
  >({ url: "/contact", method: "post", ...variables, signal });

export const useContactControllerCreateContact = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.MessageResponseWithIdDTO,
      ContactControllerCreateContactError,
      ContactControllerCreateContactVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.MessageResponseWithIdDTO,
    ContactControllerCreateContactError,
    ContactControllerCreateContactVariables
  >({
    mutationFn: (variables: ContactControllerCreateContactVariables) =>
      fetchContactControllerCreateContact({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type ContactControllerGetAllContactsQueryParams = {
  search?: string;
  /**
   * @minimum 0
   */
  take?: number;
  /**
   * @minimum 0
   */
  page?: number;
  /**
   * @format date-time
   */
  dateFrom?: string;
  /**
   * @format date-time
   */
  dateTo?: string;
  status?: "Read" | "Unread";
};

export type ContactControllerGetAllContactsError =
  Fetcher.ErrorWrapper<undefined>;

export type ContactControllerGetAllContactsVariables = {
  queryParams?: ContactControllerGetAllContactsQueryParams;
} & ApiContext["fetcherOptions"];

export const fetchContactControllerGetAllContacts = (
  variables: ContactControllerGetAllContactsVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.ListContactResponseDTO,
    ContactControllerGetAllContactsError,
    undefined,
    {},
    ContactControllerGetAllContactsQueryParams,
    {}
  >({ url: "/contact", method: "get", ...variables, signal });

export const useContactControllerGetAllContacts = <
  TData = Schemas.ListContactResponseDTO,
>(
  variables: ContactControllerGetAllContactsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ListContactResponseDTO,
      ContactControllerGetAllContactsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.ListContactResponseDTO,
    ContactControllerGetAllContactsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/contact",
      operationId: "contactControllerGetAllContacts",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchContactControllerGetAllContacts(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type ContactControllerGetSingleContactPathParams = {
  contactId: string;
};

export type ContactControllerGetSingleContactError =
  Fetcher.ErrorWrapper<undefined>;

export type ContactControllerGetSingleContactVariables = {
  pathParams: ContactControllerGetSingleContactPathParams;
} & ApiContext["fetcherOptions"];

export const fetchContactControllerGetSingleContact = (
  variables: ContactControllerGetSingleContactVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.GetContactResponseDTO,
    ContactControllerGetSingleContactError,
    undefined,
    {},
    {},
    ContactControllerGetSingleContactPathParams
  >({ url: "/contact/{contactId}", method: "get", ...variables, signal });

export const useContactControllerGetSingleContact = <
  TData = Schemas.GetContactResponseDTO,
>(
  variables: ContactControllerGetSingleContactVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.GetContactResponseDTO,
      ContactControllerGetSingleContactError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.GetContactResponseDTO,
    ContactControllerGetSingleContactError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/contact/{contactId}",
      operationId: "contactControllerGetSingleContact",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchContactControllerGetSingleContact(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type ContactControllerUpdateContactPathParams = {
  contactId: string;
};

export type ContactControllerUpdateContactError =
  Fetcher.ErrorWrapper<undefined>;

export type ContactControllerUpdateContactVariables = {
  body?: Schemas.UpdateContactRequestDTO;
  pathParams: ContactControllerUpdateContactPathParams;
} & ApiContext["fetcherOptions"];

export const fetchContactControllerUpdateContact = (
  variables: ContactControllerUpdateContactVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.MessageResponseWithIdDTO,
    ContactControllerUpdateContactError,
    Schemas.UpdateContactRequestDTO,
    {},
    {},
    ContactControllerUpdateContactPathParams
  >({ url: "/contact/{contactId}", method: "patch", ...variables, signal });

export const useContactControllerUpdateContact = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.MessageResponseWithIdDTO,
      ContactControllerUpdateContactError,
      ContactControllerUpdateContactVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.MessageResponseWithIdDTO,
    ContactControllerUpdateContactError,
    ContactControllerUpdateContactVariables
  >({
    mutationFn: (variables: ContactControllerUpdateContactVariables) =>
      fetchContactControllerUpdateContact({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type ContactControllerDeleteContactPathParams = {
  contactId: string;
};

export type ContactControllerDeleteContactError =
  Fetcher.ErrorWrapper<undefined>;

export type ContactControllerDeleteContactVariables = {
  pathParams: ContactControllerDeleteContactPathParams;
} & ApiContext["fetcherOptions"];

export const fetchContactControllerDeleteContact = (
  variables: ContactControllerDeleteContactVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.MessageResponseDTO,
    ContactControllerDeleteContactError,
    undefined,
    {},
    {},
    ContactControllerDeleteContactPathParams
  >({ url: "/contact/{contactId}", method: "delete", ...variables, signal });

export const useContactControllerDeleteContact = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.MessageResponseDTO,
      ContactControllerDeleteContactError,
      ContactControllerDeleteContactVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.MessageResponseDTO,
    ContactControllerDeleteContactError,
    ContactControllerDeleteContactVariables
  >({
    mutationFn: (variables: ContactControllerDeleteContactVariables) =>
      fetchContactControllerDeleteContact({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type MemberControllerCreateMemberError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        message: string;
        /**
         * @example Bad Request
         */
        error?: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        message: string;
        /**
         * @example Unauthorized
         */
        error?: string;
      };
    }
  | {
      status: 406;
      payload: {
        /**
         * @example 406
         */
        statusCode: number;
        message: {
          [key: string]: string[];
        };
        /**
         * @example Validation Exception
         */
        error?: string;
      };
    }
  | {
      status: 500;
      payload: {
        /**
         * @example 500
         */
        statusCode: number;
        message: string;
        /**
         * @example Internal Server Error
         */
        error?: string;
      };
    }
>;

export type MemberControllerCreateMemberVariables = {
  body: Schemas.CreateMemberRequestDTO;
} & ApiContext["fetcherOptions"];

export const fetchMemberControllerCreateMember = (
  variables: MemberControllerCreateMemberVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.MessageResponseWithIdDTO,
    MemberControllerCreateMemberError,
    Schemas.CreateMemberRequestDTO,
    {},
    {},
    {}
  >({ url: "/member", method: "post", ...variables, signal });

export const useMemberControllerCreateMember = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.MessageResponseWithIdDTO,
      MemberControllerCreateMemberError,
      MemberControllerCreateMemberVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.MessageResponseWithIdDTO,
    MemberControllerCreateMemberError,
    MemberControllerCreateMemberVariables
  >({
    mutationFn: (variables: MemberControllerCreateMemberVariables) =>
      fetchMemberControllerCreateMember({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type MemberControllerGetAllMembersQueryParams = {
  search?: string;
  /**
   * @minimum 0
   */
  take?: number;
  /**
   * @minimum 0
   */
  page?: number;
  role?: "Superadmin" | "Admin" | "Member";
};

export type MemberControllerGetAllMembersError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        message: string;
        /**
         * @example Bad Request
         */
        error?: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        message: string;
        /**
         * @example Unauthorized
         */
        error?: string;
      };
    }
  | {
      status: 500;
      payload: {
        /**
         * @example 500
         */
        statusCode: number;
        message: string;
        /**
         * @example Internal Server Error
         */
        error?: string;
      };
    }
>;

export type MemberControllerGetAllMembersVariables = {
  queryParams?: MemberControllerGetAllMembersQueryParams;
} & ApiContext["fetcherOptions"];

export const fetchMemberControllerGetAllMembers = (
  variables: MemberControllerGetAllMembersVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.ListMemberResponseDTO,
    MemberControllerGetAllMembersError,
    undefined,
    {},
    MemberControllerGetAllMembersQueryParams,
    {}
  >({ url: "/member", method: "get", ...variables, signal });

export const useMemberControllerGetAllMembers = <
  TData = Schemas.ListMemberResponseDTO,
>(
  variables: MemberControllerGetAllMembersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ListMemberResponseDTO,
      MemberControllerGetAllMembersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.ListMemberResponseDTO,
    MemberControllerGetAllMembersError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/member",
      operationId: "memberControllerGetAllMembers",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchMemberControllerGetAllMembers(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type MemberControllerUpdateMemberPathParams = {
  memberId: string;
};

export type MemberControllerUpdateMemberError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        message: string;
        /**
         * @example Bad Request
         */
        error?: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        message: string;
        /**
         * @example Unauthorized
         */
        error?: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        message: string;
        /**
         * @example Not Found
         */
        error?: string;
      };
    }
  | {
      status: 406;
      payload: {
        /**
         * @example 406
         */
        statusCode: number;
        message: {
          [key: string]: string[];
        };
        /**
         * @example Validation Exception
         */
        error?: string;
      };
    }
  | {
      status: 500;
      payload: {
        /**
         * @example 500
         */
        statusCode: number;
        message: string;
        /**
         * @example Internal Server Error
         */
        error?: string;
      };
    }
>;

export type MemberControllerUpdateMemberVariables = {
  body?: Schemas.UpdateMemberRequestDTO;
  pathParams: MemberControllerUpdateMemberPathParams;
} & ApiContext["fetcherOptions"];

export const fetchMemberControllerUpdateMember = (
  variables: MemberControllerUpdateMemberVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.MessageResponseWithIdDTO,
    MemberControllerUpdateMemberError,
    Schemas.UpdateMemberRequestDTO,
    {},
    {},
    MemberControllerUpdateMemberPathParams
  >({ url: "/member/{memberId}", method: "patch", ...variables, signal });

export const useMemberControllerUpdateMember = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.MessageResponseWithIdDTO,
      MemberControllerUpdateMemberError,
      MemberControllerUpdateMemberVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.MessageResponseWithIdDTO,
    MemberControllerUpdateMemberError,
    MemberControllerUpdateMemberVariables
  >({
    mutationFn: (variables: MemberControllerUpdateMemberVariables) =>
      fetchMemberControllerUpdateMember({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type MemberControllerGetSingleMemberPathParams = {
  memberId: string;
};

export type MemberControllerGetSingleMemberError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        message: string;
        /**
         * @example Bad Request
         */
        error?: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        message: string;
        /**
         * @example Unauthorized
         */
        error?: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        message: string;
        /**
         * @example Not Found
         */
        error?: string;
      };
    }
  | {
      status: 500;
      payload: {
        /**
         * @example 500
         */
        statusCode: number;
        message: string;
        /**
         * @example Internal Server Error
         */
        error?: string;
      };
    }
>;

export type MemberControllerGetSingleMemberVariables = {
  pathParams: MemberControllerGetSingleMemberPathParams;
} & ApiContext["fetcherOptions"];

export const fetchMemberControllerGetSingleMember = (
  variables: MemberControllerGetSingleMemberVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.SingleMemberResponseDTO,
    MemberControllerGetSingleMemberError,
    undefined,
    {},
    {},
    MemberControllerGetSingleMemberPathParams
  >({ url: "/member/{memberId}", method: "get", ...variables, signal });

export const useMemberControllerGetSingleMember = <
  TData = Schemas.SingleMemberResponseDTO,
>(
  variables: MemberControllerGetSingleMemberVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.SingleMemberResponseDTO,
      MemberControllerGetSingleMemberError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.SingleMemberResponseDTO,
    MemberControllerGetSingleMemberError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/member/{memberId}",
      operationId: "memberControllerGetSingleMember",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchMemberControllerGetSingleMember(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type MemberControllerDeleteMemberPathParams = {
  memberId: string;
};

export type MemberControllerDeleteMemberError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        message: string;
        /**
         * @example Bad Request
         */
        error?: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        message: string;
        /**
         * @example Unauthorized
         */
        error?: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        message: string;
        /**
         * @example Not Found
         */
        error?: string;
      };
    }
  | {
      status: 500;
      payload: {
        /**
         * @example 500
         */
        statusCode: number;
        message: string;
        /**
         * @example Internal Server Error
         */
        error?: string;
      };
    }
>;

export type MemberControllerDeleteMemberVariables = {
  pathParams: MemberControllerDeleteMemberPathParams;
} & ApiContext["fetcherOptions"];

export const fetchMemberControllerDeleteMember = (
  variables: MemberControllerDeleteMemberVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.MessageResponseDTO,
    MemberControllerDeleteMemberError,
    undefined,
    {},
    {},
    MemberControllerDeleteMemberPathParams
  >({ url: "/member/{memberId}", method: "delete", ...variables, signal });

export const useMemberControllerDeleteMember = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.MessageResponseDTO,
      MemberControllerDeleteMemberError,
      MemberControllerDeleteMemberVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.MessageResponseDTO,
    MemberControllerDeleteMemberError,
    MemberControllerDeleteMemberVariables
  >({
    mutationFn: (variables: MemberControllerDeleteMemberVariables) =>
      fetchMemberControllerDeleteMember({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type MemberControllerLoginMemberError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        message: string;
        /**
         * @example Bad Request
         */
        error?: string;
      };
    }
  | {
      status: 406;
      payload: {
        /**
         * @example 406
         */
        statusCode: number;
        message: {
          [key: string]: string[];
        };
        /**
         * @example Validation Exception
         */
        error?: string;
      };
    }
  | {
      status: 500;
      payload: {
        /**
         * @example 500
         */
        statusCode: number;
        message: string;
        /**
         * @example Internal Server Error
         */
        error?: string;
      };
    }
>;

export type MemberControllerLoginMemberVariables = {
  body: Schemas.MemberLoginDTO;
} & ApiContext["fetcherOptions"];

export const fetchMemberControllerLoginMember = (
  variables: MemberControllerLoginMemberVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.MessageResponseWithIdDTO,
    MemberControllerLoginMemberError,
    Schemas.MemberLoginDTO,
    {},
    {},
    {}
  >({ url: "/member/login", method: "post", ...variables, signal });

export const useMemberControllerLoginMember = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.MessageResponseWithIdDTO,
      MemberControllerLoginMemberError,
      MemberControllerLoginMemberVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.MessageResponseWithIdDTO,
    MemberControllerLoginMemberError,
    MemberControllerLoginMemberVariables
  >({
    mutationFn: (variables: MemberControllerLoginMemberVariables) =>
      fetchMemberControllerLoginMember({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type MemberControllerActiveUserError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        message: string;
        /**
         * @example Unauthorized
         */
        error?: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        message: string;
        /**
         * @example Not Found
         */
        error?: string;
      };
    }
  | {
      status: 500;
      payload: {
        /**
         * @example 500
         */
        statusCode: number;
        message: string;
        /**
         * @example Internal Server Error
         */
        error?: string;
      };
    }
>;

export type MemberControllerActiveUserVariables = ApiContext["fetcherOptions"];

export const fetchMemberControllerActiveUser = (
  variables: MemberControllerActiveUserVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.SingleMemberResponseDTO,
    MemberControllerActiveUserError,
    undefined,
    {},
    {},
    {}
  >({ url: "/member/active", method: "get", ...variables, signal });

export const useMemberControllerActiveUser = <
  TData = Schemas.SingleMemberResponseDTO,
>(
  variables: MemberControllerActiveUserVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.SingleMemberResponseDTO,
      MemberControllerActiveUserError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.SingleMemberResponseDTO,
    MemberControllerActiveUserError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/member/active",
      operationId: "memberControllerActiveUser",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchMemberControllerActiveUser(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type MemberControllerVerifyMemberError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        message: string;
        /**
         * @example Bad Request
         */
        error?: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        message: string;
        /**
         * @example Not Found
         */
        error?: string;
      };
    }
  | {
      status: 406;
      payload: {
        /**
         * @example 406
         */
        statusCode: number;
        message: {
          [key: string]: string[];
        };
        /**
         * @example Validation Exception
         */
        error?: string;
      };
    }
  | {
      status: 500;
      payload: {
        /**
         * @example 500
         */
        statusCode: number;
        message: string;
        /**
         * @example Internal Server Error
         */
        error?: string;
      };
    }
>;

export type MemberControllerVerifyMemberVariables = {
  body: Schemas.MemberVerifyDTO;
} & ApiContext["fetcherOptions"];

export const fetchMemberControllerVerifyMember = (
  variables: MemberControllerVerifyMemberVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.VerifyResponseDTO,
    MemberControllerVerifyMemberError,
    Schemas.MemberVerifyDTO,
    {},
    {},
    {}
  >({ url: "/member/login/verify", method: "post", ...variables, signal });

export const useMemberControllerVerifyMember = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.VerifyResponseDTO,
      MemberControllerVerifyMemberError,
      MemberControllerVerifyMemberVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.VerifyResponseDTO,
    MemberControllerVerifyMemberError,
    MemberControllerVerifyMemberVariables
  >({
    mutationFn: (variables: MemberControllerVerifyMemberVariables) =>
      fetchMemberControllerVerifyMember({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DepartmentControllerCreateDepartmentError =
  Fetcher.ErrorWrapper<undefined>;

export type DepartmentControllerCreateDepartmentVariables = {
  body: Schemas.CreateDepartmentDTO;
} & ApiContext["fetcherOptions"];

export const fetchDepartmentControllerCreateDepartment = (
  variables: DepartmentControllerCreateDepartmentVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.MessageResponseWithIdDTO,
    DepartmentControllerCreateDepartmentError,
    Schemas.CreateDepartmentDTO,
    {},
    {},
    {}
  >({ url: "/department", method: "post", ...variables, signal });

export const useDepartmentControllerCreateDepartment = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.MessageResponseWithIdDTO,
      DepartmentControllerCreateDepartmentError,
      DepartmentControllerCreateDepartmentVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.MessageResponseWithIdDTO,
    DepartmentControllerCreateDepartmentError,
    DepartmentControllerCreateDepartmentVariables
  >({
    mutationFn: (variables: DepartmentControllerCreateDepartmentVariables) =>
      fetchDepartmentControllerCreateDepartment({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type DepartmentControllerGetAllDepartmentsQueryParams = {
  search?: string;
  /**
   * @minimum 0
   */
  take?: number;
  /**
   * @minimum 0
   */
  page?: number;
};

export type DepartmentControllerGetAllDepartmentsError =
  Fetcher.ErrorWrapper<undefined>;

export type DepartmentControllerGetAllDepartmentsVariables = {
  queryParams?: DepartmentControllerGetAllDepartmentsQueryParams;
} & ApiContext["fetcherOptions"];

export const fetchDepartmentControllerGetAllDepartments = (
  variables: DepartmentControllerGetAllDepartmentsVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.ListDepartmentResponseDTO,
    DepartmentControllerGetAllDepartmentsError,
    undefined,
    {},
    DepartmentControllerGetAllDepartmentsQueryParams,
    {}
  >({ url: "/department", method: "get", ...variables, signal });

export const useDepartmentControllerGetAllDepartments = <
  TData = Schemas.ListDepartmentResponseDTO,
>(
  variables: DepartmentControllerGetAllDepartmentsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ListDepartmentResponseDTO,
      DepartmentControllerGetAllDepartmentsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.ListDepartmentResponseDTO,
    DepartmentControllerGetAllDepartmentsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/department",
      operationId: "departmentControllerGetAllDepartments",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchDepartmentControllerGetAllDepartments(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type DepartmentControllerGetSingleDepartmentPathParams = {
  departmentId: string;
};

export type DepartmentControllerGetSingleDepartmentError =
  Fetcher.ErrorWrapper<undefined>;

export type DepartmentControllerGetSingleDepartmentVariables = {
  pathParams: DepartmentControllerGetSingleDepartmentPathParams;
} & ApiContext["fetcherOptions"];

export const fetchDepartmentControllerGetSingleDepartment = (
  variables: DepartmentControllerGetSingleDepartmentVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.SingleDepartmentResponseDTO,
    DepartmentControllerGetSingleDepartmentError,
    undefined,
    {},
    {},
    DepartmentControllerGetSingleDepartmentPathParams
  >({ url: "/department/{departmentId}", method: "get", ...variables, signal });

export const useDepartmentControllerGetSingleDepartment = <
  TData = Schemas.SingleDepartmentResponseDTO,
>(
  variables: DepartmentControllerGetSingleDepartmentVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.SingleDepartmentResponseDTO,
      DepartmentControllerGetSingleDepartmentError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.SingleDepartmentResponseDTO,
    DepartmentControllerGetSingleDepartmentError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/department/{departmentId}",
      operationId: "departmentControllerGetSingleDepartment",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchDepartmentControllerGetSingleDepartment(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type DepartmentControllerUpdateDepartmentPathParams = {
  departmentId: string;
};

export type DepartmentControllerUpdateDepartmentError =
  Fetcher.ErrorWrapper<undefined>;

export type DepartmentControllerUpdateDepartmentVariables = {
  body?: Schemas.UpdateDepartmentDTO;
  pathParams: DepartmentControllerUpdateDepartmentPathParams;
} & ApiContext["fetcherOptions"];

export const fetchDepartmentControllerUpdateDepartment = (
  variables: DepartmentControllerUpdateDepartmentVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.MessageResponseWithIdDTO,
    DepartmentControllerUpdateDepartmentError,
    Schemas.UpdateDepartmentDTO,
    {},
    {},
    DepartmentControllerUpdateDepartmentPathParams
  >({
    url: "/department/{departmentId}",
    method: "patch",
    ...variables,
    signal,
  });

export const useDepartmentControllerUpdateDepartment = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.MessageResponseWithIdDTO,
      DepartmentControllerUpdateDepartmentError,
      DepartmentControllerUpdateDepartmentVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.MessageResponseWithIdDTO,
    DepartmentControllerUpdateDepartmentError,
    DepartmentControllerUpdateDepartmentVariables
  >({
    mutationFn: (variables: DepartmentControllerUpdateDepartmentVariables) =>
      fetchDepartmentControllerUpdateDepartment({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type DepartmentControllerDeleteDepartmentPathParams = {
  departmentId: string;
};

export type DepartmentControllerDeleteDepartmentError =
  Fetcher.ErrorWrapper<undefined>;

export type DepartmentControllerDeleteDepartmentVariables = {
  pathParams: DepartmentControllerDeleteDepartmentPathParams;
} & ApiContext["fetcherOptions"];

export const fetchDepartmentControllerDeleteDepartment = (
  variables: DepartmentControllerDeleteDepartmentVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.MessageResponseDTO,
    DepartmentControllerDeleteDepartmentError,
    undefined,
    {},
    {},
    DepartmentControllerDeleteDepartmentPathParams
  >({
    url: "/department/{departmentId}",
    method: "delete",
    ...variables,
    signal,
  });

export const useDepartmentControllerDeleteDepartment = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.MessageResponseDTO,
      DepartmentControllerDeleteDepartmentError,
      DepartmentControllerDeleteDepartmentVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.MessageResponseDTO,
    DepartmentControllerDeleteDepartmentError,
    DepartmentControllerDeleteDepartmentVariables
  >({
    mutationFn: (variables: DepartmentControllerDeleteDepartmentVariables) =>
      fetchDepartmentControllerDeleteDepartment({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type DesignationControllerCreateDesignationError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        message: string;
        /**
         * @example Bad Request
         */
        error?: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        message: string;
        /**
         * @example Unauthorized
         */
        error?: string;
      };
    }
  | {
      status: 406;
      payload: {
        /**
         * @example 406
         */
        statusCode: number;
        message: {
          [key: string]: string[];
        };
        /**
         * @example Validation Exception
         */
        error?: string;
      };
    }
  | {
      status: 500;
      payload: {
        /**
         * @example 500
         */
        statusCode: number;
        message: string;
        /**
         * @example Internal Server Error
         */
        error?: string;
      };
    }
>;

export type DesignationControllerCreateDesignationVariables = {
  body: Schemas.CreateDesignationDTO;
} & ApiContext["fetcherOptions"];

export const fetchDesignationControllerCreateDesignation = (
  variables: DesignationControllerCreateDesignationVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.MessageResponseWithIdDTO,
    DesignationControllerCreateDesignationError,
    Schemas.CreateDesignationDTO,
    {},
    {},
    {}
  >({ url: "/designation", method: "post", ...variables, signal });

export const useDesignationControllerCreateDesignation = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.MessageResponseWithIdDTO,
      DesignationControllerCreateDesignationError,
      DesignationControllerCreateDesignationVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.MessageResponseWithIdDTO,
    DesignationControllerCreateDesignationError,
    DesignationControllerCreateDesignationVariables
  >({
    mutationFn: (variables: DesignationControllerCreateDesignationVariables) =>
      fetchDesignationControllerCreateDesignation({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type DesignationControllerGetAllDesignationsQueryParams = {
  search?: string;
  /**
   * @minimum 0
   */
  take?: number;
  /**
   * @minimum 0
   */
  page?: number;
};

export type DesignationControllerGetAllDesignationsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        message: string;
        /**
         * @example Bad Request
         */
        error?: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        message: string;
        /**
         * @example Unauthorized
         */
        error?: string;
      };
    }
  | {
      status: 500;
      payload: {
        /**
         * @example 500
         */
        statusCode: number;
        message: string;
        /**
         * @example Internal Server Error
         */
        error?: string;
      };
    }
>;

export type DesignationControllerGetAllDesignationsVariables = {
  queryParams?: DesignationControllerGetAllDesignationsQueryParams;
} & ApiContext["fetcherOptions"];

export const fetchDesignationControllerGetAllDesignations = (
  variables: DesignationControllerGetAllDesignationsVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.ListDesignationResponseDTO,
    DesignationControllerGetAllDesignationsError,
    undefined,
    {},
    DesignationControllerGetAllDesignationsQueryParams,
    {}
  >({ url: "/designation", method: "get", ...variables, signal });

export const useDesignationControllerGetAllDesignations = <
  TData = Schemas.ListDesignationResponseDTO,
>(
  variables: DesignationControllerGetAllDesignationsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ListDesignationResponseDTO,
      DesignationControllerGetAllDesignationsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.ListDesignationResponseDTO,
    DesignationControllerGetAllDesignationsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/designation",
      operationId: "designationControllerGetAllDesignations",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchDesignationControllerGetAllDesignations(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type DesignationControllerGetSingleDesignationPathParams = {
  designationId: string;
};

export type DesignationControllerGetSingleDesignationError =
  Fetcher.ErrorWrapper<
    | {
        status: 400;
        payload: {
          /**
           * @example 400
           */
          statusCode: number;
          message: string;
          /**
           * @example Bad Request
           */
          error?: string;
        };
      }
    | {
        status: 401;
        payload: {
          /**
           * @example 401
           */
          statusCode: number;
          message: string;
          /**
           * @example Unauthorized
           */
          error?: string;
        };
      }
    | {
        status: 404;
        payload: {
          /**
           * @example 404
           */
          statusCode: number;
          message: string;
          /**
           * @example Not Found
           */
          error?: string;
        };
      }
    | {
        status: 500;
        payload: {
          /**
           * @example 500
           */
          statusCode: number;
          message: string;
          /**
           * @example Internal Server Error
           */
          error?: string;
        };
      }
  >;

export type DesignationControllerGetSingleDesignationVariables = {
  pathParams: DesignationControllerGetSingleDesignationPathParams;
} & ApiContext["fetcherOptions"];

export const fetchDesignationControllerGetSingleDesignation = (
  variables: DesignationControllerGetSingleDesignationVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.GetDesignationResponseDTO,
    DesignationControllerGetSingleDesignationError,
    undefined,
    {},
    {},
    DesignationControllerGetSingleDesignationPathParams
  >({
    url: "/designation/{designationId}",
    method: "get",
    ...variables,
    signal,
  });

export const useDesignationControllerGetSingleDesignation = <
  TData = Schemas.GetDesignationResponseDTO,
>(
  variables: DesignationControllerGetSingleDesignationVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.GetDesignationResponseDTO,
      DesignationControllerGetSingleDesignationError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.GetDesignationResponseDTO,
    DesignationControllerGetSingleDesignationError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/designation/{designationId}",
      operationId: "designationControllerGetSingleDesignation",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchDesignationControllerGetSingleDesignation(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type DesignationControllerUpdateDesignationPathParams = {
  designationId: string;
};

export type DesignationControllerUpdateDesignationError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        message: string;
        /**
         * @example Bad Request
         */
        error?: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        message: string;
        /**
         * @example Unauthorized
         */
        error?: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        message: string;
        /**
         * @example Not Found
         */
        error?: string;
      };
    }
  | {
      status: 406;
      payload: {
        /**
         * @example 406
         */
        statusCode: number;
        message: {
          [key: string]: string[];
        };
        /**
         * @example Validation Exception
         */
        error?: string;
      };
    }
  | {
      status: 500;
      payload: {
        /**
         * @example 500
         */
        statusCode: number;
        message: string;
        /**
         * @example Internal Server Error
         */
        error?: string;
      };
    }
>;

export type DesignationControllerUpdateDesignationVariables = {
  body?: Schemas.UpdateDesignationDTO;
  pathParams: DesignationControllerUpdateDesignationPathParams;
} & ApiContext["fetcherOptions"];

export const fetchDesignationControllerUpdateDesignation = (
  variables: DesignationControllerUpdateDesignationVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.MessageResponseWithIdDTO,
    DesignationControllerUpdateDesignationError,
    Schemas.UpdateDesignationDTO,
    {},
    {},
    DesignationControllerUpdateDesignationPathParams
  >({
    url: "/designation/{designationId}",
    method: "patch",
    ...variables,
    signal,
  });

export const useDesignationControllerUpdateDesignation = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.MessageResponseWithIdDTO,
      DesignationControllerUpdateDesignationError,
      DesignationControllerUpdateDesignationVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.MessageResponseWithIdDTO,
    DesignationControllerUpdateDesignationError,
    DesignationControllerUpdateDesignationVariables
  >({
    mutationFn: (variables: DesignationControllerUpdateDesignationVariables) =>
      fetchDesignationControllerUpdateDesignation({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type DesignationControllerDeleteDesignationPathParams = {
  designationId: string;
};

export type DesignationControllerDeleteDesignationError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        /**
         * @example 400
         */
        statusCode: number;
        message: string;
        /**
         * @example Bad Request
         */
        error?: string;
      };
    }
  | {
      status: 401;
      payload: {
        /**
         * @example 401
         */
        statusCode: number;
        message: string;
        /**
         * @example Unauthorized
         */
        error?: string;
      };
    }
  | {
      status: 404;
      payload: {
        /**
         * @example 404
         */
        statusCode: number;
        message: string;
        /**
         * @example Not Found
         */
        error?: string;
      };
    }
  | {
      status: 500;
      payload: {
        /**
         * @example 500
         */
        statusCode: number;
        message: string;
        /**
         * @example Internal Server Error
         */
        error?: string;
      };
    }
>;

export type DesignationControllerDeleteDesignationVariables = {
  pathParams: DesignationControllerDeleteDesignationPathParams;
} & ApiContext["fetcherOptions"];

export const fetchDesignationControllerDeleteDesignation = (
  variables: DesignationControllerDeleteDesignationVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.MessageResponseDTO,
    DesignationControllerDeleteDesignationError,
    undefined,
    {},
    {},
    DesignationControllerDeleteDesignationPathParams
  >({
    url: "/designation/{designationId}",
    method: "delete",
    ...variables,
    signal,
  });

export const useDesignationControllerDeleteDesignation = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.MessageResponseDTO,
      DesignationControllerDeleteDesignationError,
      DesignationControllerDeleteDesignationVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.MessageResponseDTO,
    DesignationControllerDeleteDesignationError,
    DesignationControllerDeleteDesignationVariables
  >({
    mutationFn: (variables: DesignationControllerDeleteDesignationVariables) =>
      fetchDesignationControllerDeleteDesignation({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type QueryOperation =
  | {
      path: "/vacancy";
      operationId: "vacancyControllerGetAllJobVacancy";
      variables: VacancyControllerGetAllJobVacancyVariables;
    }
  | {
      path: "/vacancy/{vacancyId}";
      operationId: "vacancyControllerFindSingleVacancy";
      variables: VacancyControllerFindSingleVacancyVariables;
    }
  | {
      path: "/applicant";
      operationId: "applicantControllerGetAllJobApplicants";
      variables: ApplicantControllerGetAllJobApplicantsVariables;
    }
  | {
      path: "/applicant/{applicantId}";
      operationId: "applicantControllerGetSingleApplicant";
      variables: ApplicantControllerGetSingleApplicantVariables;
    }
  | {
      path: "/contact";
      operationId: "contactControllerGetAllContacts";
      variables: ContactControllerGetAllContactsVariables;
    }
  | {
      path: "/contact/{contactId}";
      operationId: "contactControllerGetSingleContact";
      variables: ContactControllerGetSingleContactVariables;
    }
  | {
      path: "/member";
      operationId: "memberControllerGetAllMembers";
      variables: MemberControllerGetAllMembersVariables;
    }
  | {
      path: "/member/{memberId}";
      operationId: "memberControllerGetSingleMember";
      variables: MemberControllerGetSingleMemberVariables;
    }
  | {
      path: "/member/active";
      operationId: "memberControllerActiveUser";
      variables: MemberControllerActiveUserVariables;
    }
  | {
      path: "/department";
      operationId: "departmentControllerGetAllDepartments";
      variables: DepartmentControllerGetAllDepartmentsVariables;
    }
  | {
      path: "/department/{departmentId}";
      operationId: "departmentControllerGetSingleDepartment";
      variables: DepartmentControllerGetSingleDepartmentVariables;
    }
  | {
      path: "/designation";
      operationId: "designationControllerGetAllDesignations";
      variables: DesignationControllerGetAllDesignationsVariables;
    }
  | {
      path: "/designation/{designationId}";
      operationId: "designationControllerGetSingleDesignation";
      variables: DesignationControllerGetSingleDesignationVariables;
    };
